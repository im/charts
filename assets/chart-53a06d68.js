import{x as A}from"./index-5a5c4e60.js";const m=(e,t)=>t.some(n=>e instanceof n);let M,S;function O(){return M||(M=[IDBDatabase,IDBObjectStore,IDBIndex,IDBCursor,IDBTransaction])}function j(){return S||(S=[IDBCursor.prototype.advance,IDBCursor.prototype.continue,IDBCursor.prototype.continuePrimaryKey])}const p=new WeakMap,B=new WeakMap,P=new WeakMap,D=new WeakMap,w=new WeakMap;function R(e){const t=new Promise((n,r)=>{const s=()=>{e.removeEventListener("success",a),e.removeEventListener("error",o)},a=()=>{n(c(e.result)),s()},o=()=>{r(e.error),s()};e.addEventListener("success",a),e.addEventListener("error",o)});return t.then(n=>{n instanceof IDBCursor&&p.set(n,e)}).catch(()=>{}),w.set(t,e),t}function V(e){if(B.has(e))return;const t=new Promise((n,r)=>{const s=()=>{e.removeEventListener("complete",a),e.removeEventListener("error",o),e.removeEventListener("abort",o)},a=()=>{n(),s()},o=()=>{r(e.error||new DOMException("AbortError","AbortError")),s()};e.addEventListener("complete",a),e.addEventListener("error",o),e.addEventListener("abort",o)});B.set(e,t)}let b={get(e,t,n){if(e instanceof IDBTransaction){if(t==="done")return B.get(e);if(t==="objectStoreNames")return e.objectStoreNames||P.get(e);if(t==="store")return n.objectStoreNames[1]?void 0:n.objectStore(n.objectStoreNames[0])}return c(e[t])},set(e,t,n){return e[t]=n,!0},has(e,t){return e instanceof IDBTransaction&&(t==="done"||t==="store")?!0:t in e}};function T(e){b=e(b)}function k(e){return e===IDBDatabase.prototype.transaction&&!("objectStoreNames"in IDBTransaction.prototype)?function(t,...n){const r=e.call(I(this),t,...n);return P.set(r,t.sort?t.sort():[t]),c(r)}:j().includes(e)?function(...t){return e.apply(I(this),t),c(p.get(this))}:function(...t){return c(e.apply(I(this),t))}}function F(e){return typeof e=="function"?k(e):(e instanceof IDBTransaction&&V(e),m(e,O())?new Proxy(e,b):e)}function c(e){if(e instanceof IDBRequest)return R(e);if(D.has(e))return D.get(e);const t=F(e);return t!==e&&(D.set(e,t),w.set(t,e)),t}const I=e=>w.get(e);function N(e,t,{blocked:n,upgrade:r,blocking:s,terminated:a}={}){const o=indexedDB.open(e,t),d=c(o);return r&&o.addEventListener("upgradeneeded",i=>{r(c(o.result),i.oldVersion,i.newVersion,c(o.transaction),i)}),n&&o.addEventListener("blocked",i=>n(i.oldVersion,i.newVersion,i)),d.then(i=>{a&&i.addEventListener("close",()=>a()),s&&i.addEventListener("versionchange",u=>s(u.oldVersion,u.newVersion,u))}).catch(()=>{}),d}const W=["get","getKey","getAll","getAllKeys","count"],_=["put","add","delete","clear"],y=new Map;function x(e,t){if(!(e instanceof IDBDatabase&&!(t in e)&&typeof t=="string"))return;if(y.get(t))return y.get(t);const n=t.replace(/FromIndex$/,""),r=t!==n,s=_.includes(n);if(!(n in(r?IDBIndex:IDBObjectStore).prototype)||!(s||W.includes(n)))return;const a=async function(o,...d){const i=this.transaction(o,s?"readwrite":"readonly");let u=i.store;return r&&(u=u.index(d.shift())),(await Promise.all([u[n](...d),s&&i.done]))[0]};return y.set(t,a),a}T(e=>({...e,get:(t,n,r)=>x(t,n)||e.get(t,n,r),has:(t,n)=>!!x(t,n)||e.has(t,n)}));const v=["continue","continuePrimaryKey","advance"],C={},E=new WeakMap,L=new WeakMap,K={get(e,t){if(!v.includes(t))return e[t];let n=C[t];return n||(n=C[t]=function(...r){E.set(this,L.get(this)[t](...r))}),n}};async function*H(...e){let t=this;if(t instanceof IDBCursor||(t=await t.openCursor(...e)),!t)return;t=t;const n=new Proxy(t,K);for(L.set(n,t),w.set(n,I(t));t;)yield n,t=await(E.get(n)||t.continue()),E.delete(n)}function g(e,t){return t===Symbol.asyncIterator&&m(e,[IDBIndex,IDBObjectStore,IDBCursor])||t==="iterate"&&m(e,[IDBIndex,IDBObjectStore])}T(e=>({...e,get(t,n,r){return g(t,n)?H:e.get(t,n,r)},has(t,n){return g(t,n)||e.has(t,n)}}));const $="chart",z=1,G="folder",f="chart";let h=null;const J=()=>h||(h=N($,z,{upgrade(e){e.createObjectStore(f,{keyPath:"id",autoIncrement:!0}).createIndex("id","id",{unique:!0}),e.createObjectStore(G,{keyPath:"id",autoIncrement:!0}).createIndex("id","id",{unique:!0})}}),h),l=J(),U=A("Chart",{state:()=>({list:[]}),actions:{async update(){const e=await(await l).getAllFromIndex(f,"id");this.list=(e||[]).sort((t,n)=>n.updatedTime-t.updatedTime)},async get(e){return await(await l).transaction(f,"readwrite").store.get(+e)},async set(e){const t=(await l).transaction(f,"readwrite");if(e.id){const n=t.store.index("id");for await(const r of n.iterate(e.id)){const s=Object.assign(r.value,e);r.update(s)}return await t.done,e.id}else{const n=await t.store.add(e);return this.update(),await t.done,n}},async del(e){await(await l).delete(f,e),this.update()}}});export{J as D,G as F,U as u};
